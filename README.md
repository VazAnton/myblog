<<<<<<< HEAD
# MyBlog

Repository for "Myblog" project: https://github.com/VazAnton/myblog

## Краткая история обновлений + запуск приложения:

Проект my_blog претерпел несколько изменений с момента последнего обновления. Теперь это SpringBoot приложение,
благодаря чему все добавленные в проект зависимости настраиваются автоматически и в конфигурационных файлах
не осталось острой необходимости. Все компоненты добавленные в виде стартеров работают просто так благодаря
магии SpringBoot.

Для начала нужно скачать проект. Для это переходим по ссылке на репозиторий в GitHub из начала данного файла,
нажимаем на кнопку **code**, копируем появившийся адрес. С помощью командной строки в Git Bush переходим в директорию
с проектами, клонируем проект с применением команды git clone 'скопированный адрес с GitHub'. После подтверждения
операции путём введением пароля (при использовании пароля), папка с кодом проекта окажется в вашей директории
с остальными проектами. В дальнейшем с кодом приложения можно будет взаимодействовать, просто открыв проект в
используемой Вами среде разработки.

В приложении имеется основной класс Main.class, который является точкой входа в приложение. Чтобы запустить
приложение, достаточно найти класс, помеченный аннотацией @SpringBootApplication и произвести запуск класса
нажатием на значок зеленой стрелочки, сочетанием клавиш shift+F10 или через систему сборки (в данном случае
Gradle) вызвать задачу "gradle bootRun".

Теперь, когда приложение запущено, Вам должно быть интересно, что оно делает. Для того чтобы ответить на этот
вопрос, пройдемся по основным эндпоинтам приложения.

## Основные эндпоинты:

- а) GET "/" - редирект на "/posts";


- б) GET "posts" - список постов на странице ленты постов
  Параметры:
  search - строка с поиском по тегу поста (по умолчанию, пустая строка - все посты)
  pageSize - максимальное число постов на странице (по умолчанию, 10)
  pageNumber - номер текущей страницы (по умолчанию, 1)
  Возвращает:
  шаблон "posts.html"
  используется модель для заполнения шаблона:
  "posts" - List<Post> - список постов (id, title, text, imagePath, likesCount, comments)
  "search" - строка поиска (по умолчанию, пустая строка - все посты)
  "paging":
  "pageNumber" - номер текущей страницы (по умолчанию, 1)
  "pageSize" - максимальное число постов на странице (по умолчанию, 10)
  "hasNext" - можно ли пролистнуть вперед
  "hasPrevious" - можно ли пролистнуть назад


- в) GET "/posts/{id}" - страница с постом
  Возвращает:
  шаблон "post.html"
  используется модель для заполнения шаблона:
  "post" - модель поста (id, title, text, imagePath, likesCount, comments)


- г) GET "/posts/add" - страница добавления поста
  Возвращает:
  шаблон "add-post.html"


- д) POST "/posts" - добавление поста
  Принимает:
  "multipart/form-data"
  Параметры:
  "title" - название поста
  "text" - текст поста
  "image" - файл картинки поста (класс MultipartFile)
  "tags" - список тегов поста (по умолчанию, пустая строка)
  Возвращает:
  редирект на созданный "/posts/{id}"


- е) GET "/images/{id}" -эндпоинт, возвращающий набор байт картинки поста
  Параметры:
  "id" - идентификатор поста


- ж) POST "/posts/{id}/like" - увеличение/уменьшение числа лайков поста
  Параметры:
  "id" - идентификатор поста
  "like" - если true, то +1 лайк, если "false", то -1 лайк
  Возвращает:
  редирект на "/posts/{id}"


- з) POST "/posts/{id}/edit" - страница редактирования поста
  Параметры:
  "id" - идентификатор поста
  Возвращает:
  редирект на форму редактирования поста "add-post.html"
  используется модель для заполнения шаблона:
  "post" - модель поста (id, title, text, imagePath, likesCount, comments)


- и) POST "/posts/{id}" - редактирование поста
  Принимает:
  "multipart/form-data"
  Параметры:
  "id" - идентификатор поста
  "title" - название поста
  "text" - текст поста
  "image" - файл картинки поста (класс MultipartFile, может быть null - значит, остается прежним)
  "tags" - список тегов поста (по умолчанию, пустая строка)
  Возвращает:
  редирект на отредактированный "/posts/{id}"


- к) POST "/posts/{id}/comments" - эндпоинт добавления комментария к посту
  Параметры:
  "id" - идентификатор поста
  "text" - текст комментария
  Возвращает:
  редирект на "/posts/{id}"


- л) POST "/posts/{id}/comments/{commentId}" - эндпоинт редактирования комментария
  Параметры:
  "id" - идентификатор поста
  "commentId" - идентификатор комментария
  "text" - текст комментария
  Возвращает:
  редирект на "/posts/{id}"


- м) POST "/posts/{id}/comments/{commentId}/delete" - эндпоинт удаления комментария
  Параметры:
  "id" - идентификатор поста
  "commentId" - идентификатор комментария
  Возвращает:
  редирект на "/posts/{id}"


- н) POST "/posts/{id}/delete" - эндпоинт удаления поста
  Параметры:
  "id" - идентификатор поста
  Возвращает:
  редирект на "/posts"

## Краткое описание страниц:

В папке **resources/templates** находятся шаблоны HTML страниц с базово прописанными стилями напрямую через атрибуты
**style** элементов страниц. Всего проект содержит три шаблона HTML-страниц:

- add-post.html;


- post.html;


- posts.html;

## Используемые инструменты и технологии:

- Голый SpringFramework сменился на более простой в обращении SpringBoot благодаря чему не нужно в
  ручную настраивать ApplicationContext, DispatcherServlet и контейнер сервлетов. Отныне всю настройку берёт на
  себя фреймворк!


- Система сборки с прошлой версии приложения сменилась на Gradle;


- База данных для основной логики приложения сохранилась, используем PostgreSql (чтобы подключиться к базе данных
  **не нужно ничего настраивать дополнительно**, в файле **application.properties уже указаны все необходимые настройки
  **);


- Продолжаем использовать Hibernate, теперь в составе зависимости spring-boot-starter-jpa(ничего настраивать не
  нужно, SpringBoot всё настроил);


- Продолжаем использовать "thymeleaf", но теперь благодаря стартеру **spring-boot-starter-thymeleaf** теперь
  не нужно самостоятельно настраивать бины ITemplateResolver, SpringTemplateEngine, ViewResolver, всю работу
  берет на себя SpringBoot!;


- spring-boot-starter-web - стартер содержащий встроенный контейнер сервлетов Tomcat, более того именно благодаря
  этому стартеру настраиваются автоматически ApplicationContext, DispatcherServlet.

- Продолжаем использовать **Mapstruct**. Для применения этого инструмента не нужно настраивать бины даже в
  классическом spring-приложении. Всё что требуется, не ошибиться в файле build-gradle;


- Использование **lombok** как зависимости также, как и применение mapstruct, не претерпело изменений;

## Тестирование приложения:

Для тестирования приложения используются следующие зависимости и инструменты:

- **spring-boot-starter-test** - основная зависимость, используемая для тестирования spring-приложения. Содержит
  необходимые assert-выражения, применяемые в тестовом коде, такие как assertEquals(), assertTrue(),
  assertThat() и т.д.


- Для тестирования репозиториев появилась потребность в более легковесной чем PostgreSql базе данных, выбор
  был сделан в пользу используемой ранее в предыдущих проектах H2. Настройки для доступа к базе данных находятся
  в файле application-test.properties, которые применяются автоматически в классах PostRepositoryTest и
  CommentRepositoryTest из-за использования аннотации @ActiveProfiles("test) над указанными классами.

Логика тестирования описана в классах директории src/test.

Классы PostRepositoryTest и CommentRepositoryTest
проверяют корректность сохранения сущностей в базу данных, нахождение нужных данных и правильность их удаления.

Классы PostServiceImplTest b CommentServiceImplTest проверяют правильность работы написанной бизнес-логики без
прямого обращения к внешним сервисам, например, БД. Вместо это в описанных классах происходит подмена реальных
компонентов программы Mock-объектами, с изначально настроенной логикой взаимодействия с тестовыми сущностями.

Класс PostControllerIntegrationTest содержит интеграционные тесты для проверки взаимодействия друг с другом реальных
компонентов приложения. Тесты являются ресурсозатратными, поднимается весь контекст приложения, происходит
имитация реального взаимодействия с основными эндпоинтами приложения. Результат взаимодействия оценивается
с помощью логических выражений, создаваемых с использованием методов интерфейса **ResultMatcher**, а построение
самих запросов осуществляется за счёт обращения к методам фабрики **MockMvcRequestBuilders**.
=======
Repository for "Myblog" project: https://github.com/VazAnton/myblog
>>>>>>> 5a9ae4a20bb052825d616caf142f212688bb30cc
